package main

import (
	db "gotaxi/repository"
	"gotaxi/routes"
)

/*
выдели для каложения отдельынй пакет, пока у тебя оно одно (один файл с package main), но может стать больше, например

/cmd/server/main.go - основное приложение
/cmd/workers/worker_1/main.go - какие-то доп воркеры, которые билдятся как отдельный исполняемый файл, и запускаются например на кроне, или просто лежат на сервере и у тебя заготовлены команды запуска через Makefile
/cmd/workers/worker_2/main.go
/cmd/workers/worker_N/main.go

Короче прилаг в рамках 1 проекта может быть не одна, так что разбить их - хорошая идея
*/

func main() {

	/*
		Вкусовщина, но я люблю когда все файлы main.go выполняют 1 строчку и выглядят как-то так:

		func main() {
			app.Run()
		}
	*/

	/*
		В начале прилаги надо отлдовить паники, чтоб приложение не падало если че-то словит

		defer func() {
			if recoverErr := recover(); recoverErr != nil {
				// далее отправляем ошибку в системы мониторинга, например в сентрю. В данном случае будет достаточно в стд лог
			}
		}()

		Паника пусть падает при старте приложения, а когда оно уже работает - лучше ее отлавливать
	*/

	// Инициализация БД
	if err := db.InitDB(); err != nil {
		log.Fatalf("Database initialization failed: %v", err)
	}
	defer db.CloseDB()

	//Инициализация веб севера
	routes.ServerInit() // Хорошо бы запустить его в отдельной рутине,

	/*
		а ниже ловить сигналы ОС для остановки прилаги, что-то типо того:

		quit := make(chan os.Signal, 1)
		signal.Notify(quit, syscall.SIGTERM, syscall.SIGINT)
		<-quit // текущая рутина тут заблокируется и будет ждать сингала

		...
		и далее завершить все коннекты к базе итд, в общем вызвать все доступные методы Close (через defer тоже ок)

	*/
}
